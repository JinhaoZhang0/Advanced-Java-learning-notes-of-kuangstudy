# Spring

## 1. Spring

### 1.1 简介

* Spring：春天---> 给软件行业带来春天！
* 2002，首次推出了Spring框架的雏形：interface21框架
* Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日，发布了1.0正式版
* Rod Johnson，创始人
* Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架!



* SSH:  Struct2 + Spring + Hibernate
* **SSM: SpringMVC + Spring + Mybatis!**

官网：[Spring Framework](https://spring.io/projects/spring-framework)

官方下载地址：[Index of release/org/springframework/spring](https://repo.spring.io/release/org/springframework/spring/)

官方说明：[Core Technologies (spring.io)](https://docs.spring.io/spring-framework/docs/5.2.9.RELEASE/spring-framework-reference/core.html#spring-core)

GitHub：[spring-projects/spring-framework: Spring Framework (github.com)](https://github.com/spring-projects/spring-framework)



Maven:

```xml
<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.2.14.RELEASE</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.3.5</version>
</dependency>
```

### 1.2 优点

* Spring是一个开源的免费的框架（容器）！
* Spring是一个轻量级的，非侵入式的框架！
* 控制反转（IOC，Inversion of Control），面向切面编程（AOP，Aspect-Oriented Programming）
* 支持事务的处理，对框架整合的支持！

==总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！==

### 1.3 组成

<img src="images/123.png" alt="123" style="zoom:50%;" />

![124](images/124.gif)

### 1.4 拓展

Spring Boot: Build anything

Spring Cloud: Coodinate anything

Spring Cloud Data Flow: Connect everything

现代化的Java开发，就是基于Spring开发

* Spring Boot:
  * 一个快速开发的脚手架
  * 基于Spring Boot可以快速开发单个微服务
  * 约定大于配置
* Spring Cloud
  * 基于Spring Cloud是基于Spring Boot实现的

因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！

**弊端：发展了太久以后，违背了原来的概念！配置十分繁琐，人称“配置地狱”！**



## 2.  IOC理论推导

### 2.1 推导

1. UserDao 接口

   ```java
   public interface UserDao {
       void getUser();
   }
   ```

2. UserDaoImpl 实现类

   ```java
   public class UserDaoImpl implements UserDao{
       @Override
       public void getUser() {
           System.out.println("默认获取用户的数据");
       }
   }
   public class UserDaoMysqlImpl implements UserDao{
       @Override
       public void getUser() {
           System.out.println("Mysql获取用户数据");
       }
   }
   //多个实现类
   ```

3. UserService 业务接口

   ```java
   public interface UserService {
       void getUser();
   	
       //业务接口注入
       void setUserDao(UserDao userDao);
   }
   ```

4. UserServiceImpl 业务实现类

   ```java
   public class UserServiceImpl implements UserService{
   
       private UserDao userDao;
   
       //利用set进行动态实现值的注入
       public void setUserDao(UserDao userDao) {
           this.userDao = userDao;
       }
       
       @Override
       public void getUser() {
           userDao.getUser();
       }
   }
   ```

在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！

<img src="images/125.jpg" alt="125" style="zoom:40%;" />

我们使用了一个set接口实现

```java
//利用set进行动态实现值的注入
public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
}
```

* 之前，程序是主动创建对象！控制权在程序员手上！
* 使用了set注入后，程序不再具备主动性，而是变成了被动的接受对象！

这种思想，从本质上解决了问题，我们程序员不用去管理对象的创建了。系统的耦合性大大降低，可以更加专注在业务的实现上！这是IOC的原型。

<img src="images/126.jpg" alt="126" style="zoom:40%;" />

### 2.2 本质

**控制反转IoC (Inversion of Control)，是一种设计思想，DI (依赖注入) 是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。

<img src="images/127.jpg" alt="127" style="zoom:80%;" />

采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。

**控制反转是一种通过描述 (XML或注解) 并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入 (Dependency Injection, DI)。**



**打比方：**

* 原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待
* 现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的需要的菜送上来
* 此时的区别是：如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来

## 3. HelloSpring

**Hello.java**

```java
public class Hello {
    private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }

    @Override
    public String toString() {
        return "Hello{" +
                "str='" + str + '\'' +
                '}';
    }
}

```

**Beans.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--使用Spring来创建对象，在Spring中这些都称为Bean
        类型 变量名 = new 类型();
        Hello hello = new Hello();

        id = 变量名
        class = new 的对象
        property 相当于给对象中的属性设置一个值！
    -->
    <bean id="hello" class="com.jin.pojo.Hello">
        <property name="str" value="Spring"/>
    </bean>

</beans>
```

```java
//Test
public class MyTest {
    public static void main(String[] args) {
        //获取Spring的上下文对象
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        //我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来就可以！
       	//Hello hello = (Hello) context.getBean("hello");
        //在第二参数中设置类属性，则不用强转
        Hello hello = context.getBean("user", Hello.class);
        System.out.println(hello);
    }
}
```

#### 思考问题：

* hello对象是谁创建的？

  hello对象是有Spring创建的

* hello对象的属性是怎么设置的？

  hello对象的属性是由Spring容器设置的，这个过程就叫控制反转。

控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。

反转：程序本身不创建对象，而变成被动的就收对象。

依赖注入：就是利用set方法来进行注入的。

IOC是一种编程思想，由主动的编程变成被动的接收。

可以通过newClassPathXmlApplicationContext去浏览一下底层源码。

<img src="images/128.jpg" alt="128" style="zoom:40%;" />

按照对JavaBean的理解，我们可以修改之前的UserService项目，先创建beans.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="mysqlImpl" class="com.jin.dao.UserDaoMysqlImpl"/>
    <bean id="oracleImpl" class="com.jin.dao.UserDaoOracleImpl"/>

    <bean id="userServiceImpl" class="com.jin.service.UserServiceImpl">
        <!--
        ref : 引用Spring容器中创建好的对象
        value : 具体的值，基本数据类型
        -->
        <property name="userDao" ref="mysqlImpl"/>
    </bean>
</beans>
```

```java
//test代码修改如下
public static void main(String[] args) {
    //        //用户实际调用的是业务层，dao层他们不需要接触！
    //        UserService userService = new UserServiceImpl();
    //        userService.setUserDao(new UserDaoOracleImpl());
    //        userService.getUser();

    //获取ApplicationContext；拿到Spring容器
    ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");

    //容器在手，天下我有，需要什么，就直接get什么！
    UserService userService = (UserService) context.getBean("userServiceImpl");
    userService.getUser();
}
```

OK，到了现在，我们彻底不用在程序中去改动了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓的IoC，一句话搞定：对象由Spring来创建，管理，装配。

## 4. <span id="constructorInjection">IOC创建对象的方式</span>

1. 使用无参构造创建对象，默认！

2. 假设我们要使用有参构造创建对象

   1. 下标赋值

      ```xml
      <!--第一种下标赋值-->
      <bean id="user" class="com.jin.pojo.User">
          <constructor-arg index="0" value="狂神说Java"/>
      </bean>
      ```

   2. 类型

      ```xml
      <!--第二种方式：通过类型创建，不建议使用-->
      <bean id="user" class="com.jin.pojo.User">
          <constructor-arg type="java.lang.String" value="秦疆"/>
      </bean>
      ```

   3. 参数名

      ```xml
      <!--第三种：直接通过参数名来设置-->
      <bean id="user" class="com.jin.pojo.User">
          <constructor-arg name="name" value="秦疆"/>
      </bean>
      ```

总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！



## 5. Spring 配置

### 5.1 别名

```xml
<!--别名，如果添加了别名，我们也可以使用别名获取到这个对象-->
<alias name="user" alias="userNew"/>
```

别名主要用在繁杂的全限定名（这里的情况）或者同个类多个场景的时候用（下面的情况）。
java无法多继承因而有了接口；同个类无法多个id所以有了别名。

### 5.2 Bean的配置

```xml
<!--
    id : bean 的唯一标识符，也就是相当于我们学的对象名
    class : bean 对象所对应的全限定名：包名 + 类型
    name : 也是别名，而且name可以取多个别名
    -->
<bean id="userT" class="com.jin.pojo.UserT" name="user2 u2,u3">
    <property name="name" value="悟空"/>
</bean>
```

还有scope：其中有singleton，不过beans默认单例

### 5.3 import

这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个

假设，现在项目中有多个人开发，这三个人复制不同的类的开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！

* 张三
* 李四
* 王五
* applicationContext.xml

```xml
<import resource="bean.xml"/>
<import resource="bean2.xml"/>
<import resource="bean3.xml"/>
```

使用的时候，直接使用总的配置就可以了



## 6. 依赖注入

```javascript
为何官方推荐构造器？ 构造器注入和属性注入的循环依赖的报错提示也有点不同，前者编译时就报错，后者使用时报错
```

### 6.1 构造器注入

```xml
<constructor-arg index="0" value="狂神说Java"/>
<constructor-arg type="java.lang.String" value="秦疆"/>
<constructor-arg name="name" value="秦疆"/>
```

[前面](#constructorInjection)已经说过了，有参构造三种方式：

1. 下标赋值
2. 类型
3. 参数名

### 6.2 set方式注入【重点】

* 依赖注入： set注入！
  * 依赖：bean对象的创建依赖于容器
  * 注入：bean对象中的所有属性，由容器来注入！

【环境搭建】

1. 复杂类型

   ```java
   public class Address {
       private String address;
   
       public String getAddress() {
           return address;
       }
   
       public void setAddress(String address) {
           this.address = address;
       }
   }
   ```

2. 真实测试对象

   ```java
   public class Student {
       private String name;
       private Address address;
       private String[] books;
       private List<String> hobbies;
       private Map<String,String> card;
       private Set<String> games;
       private String wife;
       private Properties info;
   }
   ```

3. Beans.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
   
       <bean id="address" class="com.jin.pojo.Address">
           <property name="address" value="西安"/>
       </bean>
   
       <bean id="student" class="com.jin.pojo.Student">
           <!--普通值注入，value-->
           <property name="name" value="秦疆"/>
           <!--bean注入，ref-->
           <property name="address" ref="address"/>
           <!--数组-->
           <property name="books">
               <array>
                   <value>红楼梦</value>
                   <value>水浒传</value>
                   <value>西游记</value>
                   <value>三国演义</value>
               </array>
           </property>
           <!--list-->
           <property name="hobbies">
               <list>
                   <value>听歌</value>
                   <value>敲代码</value>
                   <value>看电影</value>
               </list>
           </property>
           <!--map-->
           <property name="card">
               <map>
                   <entry key="身份证" value="111111222222223333"/>
                   <entry key="银行卡" value="12321312313"/>
               </map>
           </property>
           <!--set-->
           <property name="games">
               <set>
                   <value>LOL</value>
                   <value>COC</value>
                   <value>BOB</value>
               </set>
           </property>
           <!--null-->
           <property name="wife">
               <null/>
           </property>
           <!--properties-->
           <property name="info">
               <props>
                   <prop key="driver">ere</prop>
                   <prop key="url">e</prop>
                   <prop key="username">root</prop>
                   <prop key="password">123456</prop>
               </props>
           </property>
       </bean>
   
   </beans>
   ```

4. 测试类

   ```java
   public class MyTest {
       public static void main(String[] args) {
           ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
           Student student = (Student) context.getBean("student");
           System.out.println(student);
           /**
            * Student{
            * name='秦疆',
            * address=Address{address='西安'},
            * books=[红楼梦, 水浒传, 西游记, 三国演义],
            * hobbies=[听歌, 敲代码, 看电影],
            * card={身份证=111111222222223333, 银行卡=12321312313},
            * games=[LOL, COC, BOB],
            * wife='null',
            * info={password=123456, driver=ere, url=e, username=root}}
            */
       }
   }
   ```

### 6.3 拓展方式注入

我们可以使用p命名空间和c命名空间进行注入。

官方解释：

<img src="images/129.jpg" alt="129" style="zoom:40%;" />

使用：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"	p命名空间注入
       xmlns:c="http://www.springframework.org/schema/c"	c命名空间注入	
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--p命名空间注入，可以直接注入属性的值：properties-->
    <bean id="user" class="com.jin.pojo.User" p:name="秦疆" p:age="18"/>

    <!--c命名空间注入，通过构造器注入：constructor-->
    <bean id="user2" class="com.jin.pojo.User" c:name="18" c:age="狂神"/>
</beans>
```

测试：

```java
@Test
public void test2(){
    ApplicationContext context = new ClassPathXmlApplicationContext("userbeans.xml");
    //在第二参数中设置类属性，则不用强转
    User user = context.getBean("user", User.class);
    System.out.println(user);
}
```

注意点：p命名空间和c命名空间不能直接使用，要导入xml约束！

```xml
xmlns:p="http://www.springframework.org/schema/p"	
xmlns:c="http://www.springframework.org/schema/c"
```

### 6.4 bean的作用域

<img src="images/130.jpg" alt="130" style="zoom:50%;" />

1. 单例模式：（Spring默认机制）

```xml
<bean id="user2" class="com.jin.pojo.User" c:name="18" c:age="狂神" scope="singleton"/>
```

2. 原型模式：每次从容器中get的时候，都会产生一个新对象

```xml
<bean id="user2" class="com.jin.pojo.User" c:name="18" c:age="狂神" scope="prototype"/>
```

3. 其余的request, session, application, websocket，只能在web开发中才会使用到。

